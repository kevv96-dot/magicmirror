/* i2c - Codigo en C para utilizar la pantalla OLED SSD1366 esp32 

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "driver/gpio.h"
#include "esp_adc_cal.h"
#include "sdkconfig.h"
#include <string.h>

#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "ssd1366.h"
#include "font8x8_basic.h"

#define SDA_PIN GPIO_NUM_15
#define SCL_PIN GPIO_NUM_2

#define tag "SSD1306"

#define GPIO_COLUMNA_1    35
#define GPIO_COLUMNA_2    32 
#define GPIO_COLUMNA_3    33
#define GPIO_COLUMNA_4    25
#define GPIO_RENGLON_1    26
#define GPIO_RENGLON_2    27
#define GPIO_RENGLON_3    14
#define GPIO_RENGLON_4    12
//GPIO 34
#define GPIO_RENGLONES_SEL 	((1ULL<<GPIO_RENGLON_1) | (1ULL<<GPIO_RENGLON_2) | (1ULL<<GPIO_RENGLON_3) | (1ULL<<GPIO_RENGLON_4))
#define GPIO_COLUMNAS_SEL 	((1ULL<<GPIO_COLUMNA_1) | (1ULL<<GPIO_COLUMNA_2) |(1ULL<<GPIO_COLUMNA_3) |(1ULL<<GPIO_COLUMNA_4))
//Define las filas para la comunicaciÃƒ3n de eventos del teclado y del ADC
QueueHandle_t xFIFOTeclado, xFIFOOLED;
// define la tarea del teclado
static void TaskTeclado( void *pvParameters );
void Task_ssd1306_display_text(const void *arg_text);

void Task_Funcion_String(int linea, int Num_Letra, int variable, const void *texto){
	
	char *text = (char*)texto;
	
	char num[] = {"                "};
	char num2[] = {"                "};
	int cont = 0;
	while(variable > 0){
		num2[cont++] = variable - (variable / 10) * 10 + '0';
		variable/=10;
	}
	for(int x=0; x<cont; x++)
		num[Num_Letra + x] = num2[cont - x - 1];
	if(variable == 0 && cont == 0)
		num[Num_Letra] = '0';
	for(int i=Num_Letra; i<16; i++)
		text[i + linea * 17] = num [i];
}

void i2c_master_init()
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 1000000
	};
	i2c_param_config(I2C_NUM_0, &i2c_config);
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
}

void ssd1306_init() {
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP, true);
	i2c_master_write_byte(cmd, 0x14, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP, true); // reverse left-right mapping
	i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE, true); // reverse up-bottom mapping

	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
		ESP_LOGI(tag, "OLED configured successfully");
	} else {
		ESP_LOGE(tag, "OLED configuration failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
}

void app_main()
{
	
	i2c_master_init();
	ssd1306_init();
	
	uint64_t tecla, num;
	
	gpio_config_t io_conf;
	//Configura los renglones como salida//deshabilita las interrupciones
	io_conf.intr_type = GPIO_PIN_INTR_DISABLE;
	//Configura como salida
	io_conf.mode = GPIO_MODE_OUTPUT;
	//Mascara de bits de las terminales que se desea configurar
	io_conf.pin_bit_mask = GPIO_RENGLONES_SEL;
	//deshabilita el modo pull-down
	io_conf.pull_down_en = 0;
	//habilita el pull-up
	io_conf.pull_up_en = 0;
	//configura las GPIO con los valores indicados
	gpio_config(&io_conf);
	//Configura las columnas como entrada conpull-up
	//habilita las interrupciones con flanco de bajada
	io_conf.intr_type = GPIO_PIN_INTR_NEGEDGE;
	//Configura como salida
	io_conf.mode = GPIO_MODE_INPUT;
	//Mascara de bits de las terminales que se desea configurar
	io_conf.pin_bit_mask = GPIO_COLUMNAS_SEL;
	//habilita el modo pull-down
	io_conf.pull_down_en = 1;
	//deshabilita el pull-up
	io_conf.pull_up_en = 0;
	//configura las GPIO con los valores indicados
	gpio_config(&io_conf);
	//crea el FIFO del teclado
	xFIFOTeclado = xQueueCreate(10,sizeof(uint64_t));
	//crea el FIFO del OLED
	xFIFOOLED = xQueueCreate(10,sizeof(uint64_t));
	//Inicia la tarea del teclado
	xTaskCreate(TaskTeclado, "tareaTeclado", 2048, NULL, 10, NULL);
	//Inicia la tarea del OLED
	xTaskCreate(&Task_ssd1306_display_text, "ssd1306_display_text",  2048, NULL, 10, NULL);
	
	while(1){
		//Si se presiona una tecla en los siguientes dos Tics,
		//la muestra
		if(xQueueReceive(xFIFOTeclado, &tecla, 2)) {
			xQueueSendToBack(xFIFOTeclado,&tecla,portMAX_DELAY);
		}	
		//Si se recibe una muestra del OLED en siguientes dos Tics,
		//la muestra
		if(xQueueReceive(xFIFOOLED, &num, 2)) {
			printf("OLED: %d\n", (uint32_t)num);
		}
	}
}
//arreglo con los numeros de GPIO de las diferentes columnas y renglones del
//Teclado multiplexado
int columnas[]={GPIO_COLUMNA_1,GPIO_COLUMNA_2,GPIO_COLUMNA_3,GPIO_COLUMNA_4};
int renglones[]={GPIO_RENGLON_1,GPIO_RENGLON_2,GPIO_RENGLON_3,GPIO_RENGLON_4};

static void TaskTeclado(void *pvParameters) //This is a task.
{
	int renglon,columna,teclaPresionada;
	int codigo,codigoAnterior;
	static int numero=0,PWM=0;
	uint32_t manda[2];
	//(void) pvParameters;
	codigoAnterior=-1;
	for(renglon=0;renglon<4;renglon++)
		gpio_set_level(renglones[renglon],0);
	
	for (;;) // una tarea nunca debe retornar o salir
	{
		teclaPresionada=0;codigo=0;
		//exploracion del teclado multiplexado
		for(renglon=0;renglon<4;renglon++){
			gpio_set_level(renglones[renglon],1);
			for(columna=0;columna<4;columna++){
			//printf("r:%d c: %d in:%d\n",renglon,columna,gpio_get_level(columnas[columna]));
				if(gpio_get_level(columnas[columna])==1) {
					teclaPresionada=1;
					codigo=(columna)|(renglon<<2);
				}
			}
			gpio_set_level(renglones[renglon],0);
		}
		//eliminacion de rebotes
		if(teclaPresionada==1){
			if (codigo==codigoAnterior){
				switch(codigo)
				{
					case 0:
					numero = numero*10 +7;
					break;
					case 1:
					numero = numero*10 +8;
					break;
					case 2:
					numero = numero*10 +9;
					break;
					case 3:
					PWM = numero;
					break;
					case 4:
					numero = numero*10 +4;
					break;
					case 5:
					numero = numero*10 +5;
					break;
					case 6:
					numero = numero*10 +6;
					break;
					case 7:
					numero = numero/10;
					break;
					case 8:
					numero = numero*10 +1;
					break;
					case 9:
					numero = numero*10 +2;
					break;
					case 10:
					numero = numero*10 +3;
					break;
					case 11:
					numero = 0;
					break;
					case 12:
					numero = numero*10 +0;
					break;
					case 13:
					
					break;
					case 14:
					
					break;
					case 15:
					
					break;
				}
				//meter a la fila el codigo de la tecla
				
				uint64_t bfd = (uint64_t)numero | ((uint64_t)PWM<<32);
				xQueueSendToBack(xFIFOTeclado,&bfd,portMAX_DELAY);
				vTaskDelay( 150 / portTICK_RATE_MS ); //espera durante 150ms
			}
			codigoAnterior=codigo;
			vTaskDelay( 50 / portTICK_RATE_MS ); //espera durante 50 ms
		}else{
			codigoAnterior=-1;
			vTaskDelay( 20 / portTICK_RATE_MS ); //espera durante 20ms
		}
	}
}

void Task_ssd1306_display_text(const void *arg_text) {
	char text[] = {"   Hola   \n"};
	uint8_t text_len = strlen(text);

	i2c_cmd_handle_t cmd;
	uint32_t nume=0,pwm=0,eco=0;
	uint64_t resiv=0;
	
while(1){
	xQueueReceive(xFIFOTeclado, &resiv, 2);
	uint8_t cur_page = 0;
	nume = (uint32_t)resiv;
	pwm = (uint32_t)(resiv >> 32);
	cmd = i2c_cmd_link_create();
	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
	i2c_master_write_byte(cmd, 0x00, true); // reset column
	i2c_master_write_byte(cmd, 0x10, true);
	i2c_master_write_byte(cmd, 0xB0 | cur_page, true); // reset page

	i2c_master_stop(cmd);
	i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);
	
	Task_Funcion_String(2, 9, nume, &text);
	Task_Funcion_String(4, 8, pwm, &text);
	Task_Funcion_String(6, 7, eco, &text);

	for (uint8_t i = 0; i < text_len; i++) {
		if (text[i] == '\n') {
			cmd = i2c_cmd_link_create();
			i2c_master_start(cmd);
			i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
			i2c_master_write_byte(cmd, 0x00, true); // reset column
			i2c_master_write_byte(cmd, 0x10, true);
			i2c_master_write_byte(cmd, 0xB0 | ++cur_page, true); // increment page

			i2c_master_stop(cmd);
			i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
			i2c_cmd_link_delete(cmd);
		} else {
			cmd = i2c_cmd_link_create();
			i2c_master_start(cmd);
			i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
			i2c_master_write(cmd, font8x8_basic_tr[(uint8_t)text[i]], 8, true);

			i2c_master_stop(cmd);
			i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
			i2c_cmd_link_delete(cmd);
		}
	}
	xQueueSendToBack(xFIFOOLED,&nume,portMAX_DELAY);
	vTaskDelay( 150 / portTICK_RATE_MS ); //espera durante 150ms
}
	//vTaskDelete(NULL);
}

